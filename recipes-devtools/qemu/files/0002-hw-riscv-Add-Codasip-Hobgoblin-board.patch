From a6a4416704a2f80b4d41d424f2cf9432e06a40c2 Mon Sep 17 00:00:00 2001
From: Stuart Menefy <stuart.menefy@codasip.com>
Date: Sun, 31 Dec 2023 10:59:13 +0000
Subject: [PATCH 02/17] hw/riscv: Add Codasip Hobgoblin board

Signed-off-by: Stuart Menefy <stuart.menefy@codasip.com>
---
 configs/devices/riscv32-softmmu/default.mak |   1 +
 configs/devices/riscv64-softmmu/default.mak |   1 +
 hw/riscv/Kconfig                            |   5 +
 hw/riscv/hobgoblin.c                        | 325 ++++++++++++++++++++
 hw/riscv/meson.build                        |   1 +
 include/hw/riscv/hobgoblin.h                |  43 +++
 6 files changed, 376 insertions(+)
 create mode 100644 hw/riscv/hobgoblin.c
 create mode 100644 include/hw/riscv/hobgoblin.h

diff --git a/configs/devices/riscv32-softmmu/default.mak b/configs/devices/riscv32-softmmu/default.mak
index d847bd5692..aab67871ed 100644
--- a/configs/devices/riscv32-softmmu/default.mak
+++ b/configs/devices/riscv32-softmmu/default.mak
@@ -11,5 +11,6 @@ CONFIG_ARM_COMPATIBLE_SEMIHOSTING=y
 CONFIG_SPIKE=y
 CONFIG_SIFIVE_E=y
 CONFIG_SIFIVE_U=y
+CONFIG_HOBGOBLIN=y
 CONFIG_RISCV_VIRT=y
 CONFIG_OPENTITAN=y
diff --git a/configs/devices/riscv64-softmmu/default.mak b/configs/devices/riscv64-softmmu/default.mak
index bc69301fa4..4f707c07a3 100644
--- a/configs/devices/riscv64-softmmu/default.mak
+++ b/configs/devices/riscv64-softmmu/default.mak
@@ -14,3 +14,4 @@ CONFIG_SIFIVE_U=y
 CONFIG_RISCV_VIRT=y
 CONFIG_MICROCHIP_PFSOC=y
 CONFIG_SHAKTI_C=y
+CONFIG_HOBGOBLIN=y
diff --git a/hw/riscv/Kconfig b/hw/riscv/Kconfig
index b6a5eb4452..4d7784368d 100644
--- a/hw/riscv/Kconfig
+++ b/hw/riscv/Kconfig
@@ -85,3 +85,8 @@ config SPIKE
     select HTIF
     select RISCV_ACLINT
     select SIFIVE_PLIC
+
+config HOBGOBLIN
+    bool
+    select RISCV_ACLINT
+    select SIFIVE_PLIC
diff --git a/hw/riscv/hobgoblin.c b/hw/riscv/hobgoblin.c
new file mode 100644
index 0000000000..198572eb59
--- /dev/null
+++ b/hw/riscv/hobgoblin.c
@@ -0,0 +1,325 @@
+/*
+ * QEMU RISC-V Hobgoblin Board
+ *
+ * Copyright (c) 2023 Stuart Menefy, stuart.menefy@codasip.com
+ * Copyright (c) 2023 Codasip Limited
+ *
+ * This provides a RISC-V Board with the following devices:
+ *
+ * 1) CLINT (Timer and IPI)
+ * 2) PLIC (Platform Level Interrupt Controller)
+ * 3) 16550 UART
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2 or later, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/log.h"
+#include "qemu/error-report.h"
+#include "qapi/error.h"
+#include "hw/boards.h"
+#include "hw/loader.h"
+#include "hw/sysbus.h"
+#include "target/riscv/cpu.h"
+#include "hw/riscv/riscv_hart.h"
+#include "hw/intc/riscv_aclint.h"
+#include "hw/intc/sifive_plic.h"
+#include "hw/riscv/hobgoblin.h"
+#include "hw/riscv/boot.h"
+#include "hw/char/serial.h"
+#include "chardev/char.h"
+#include "sysemu/arch_init.h"
+#include "sysemu/device_tree.h"
+#include "sysemu/qtest.h"
+#include "sysemu/sysemu.h"
+#include "exec/address-spaces.h"
+
+static const struct MemmapEntry {
+    hwaddr base;
+    hwaddr size;
+} hobgoblin_memmap[] = {
+    [HOBGOBLIN_MROM] =     {     0x1000,      0x100 },
+    [HOBGOBLIN_PLIC] =     { 0x40000000,  0x4000000 },
+    [HOBGOBLIN_CLINT] =    { 0x60014000,     0xc000 },
+    [HOBGOBLIN_UART0] =    { 0x60100000,     0x1020 },
+    [HOBGOBLIN_DRAM] =     { 0x80000000, 0x40000000 },
+};
+
+#define HOBGOBLIN_PLIC_HART_CONFIG "M" /* Not "MS" unfortunatly */
+#define HOBGOBLIN_PLIC_NUM_SOURCES 32
+#define HOBGOBLIN_PLIC_NUM_PRIORITIES 7
+#define HOBGOBLIN_PLIC_PRIORITY_BASE 0x04
+#define HOBGOBLIN_PLIC_PENDING_BASE 0x1000
+#define HOBGOBLIN_PLIC_ENABLE_BASE 0x2000
+#define HOBGOBLIN_PLIC_ENABLE_STRIDE 0x80
+#define HOBGOBLIN_PLIC_CONTEXT_BASE 0x200000
+#define HOBGOBLIN_PLIC_CONTEXT_STRIDE 0x1000
+
+#define HOBGOBLIN_UART0_IRQ     1
+
+/* CLINT timebase frequency */
+#define CLINT_TIMEBASE_FREQ 100000000
+
+#define CFG_ID_NONE -1
+#define CFG_ID_BOOT 0
+#define CFG_ID_FDT 1
+#define CFG_ID_NXT 2
+#define CFG_ID_COUNT (CFG_ID_NXT+1)
+
+struct cfg_entry {
+    const char* filename;
+    hwaddr address;
+};
+
+static struct cfg_entry* hobgoblin_parse_cfg(const char *cfg_path,
+                int *num_entries_p, int id_entries[CFG_ID_COUNT])
+{
+    FILE *file;
+    char *buf;
+    size_t buf_size;
+    ssize_t line_len;
+    int line_number = 1;
+    struct cfg_entry *entries;
+    int entries_alloced;
+    int num_entries;
+    const char *id_names[] = {
+        "BOOT", "FDT", "NXT"
+    };
+
+    file = fopen(cfg_path, "r");
+    if (file == NULL) {
+        error_report("%s: open %s failed", __func__, cfg_path);
+        return NULL;
+    }
+
+    entries = NULL;
+    entries_alloced = 0;
+    num_entries = 0;
+
+    buf = NULL;
+    buf_size = 0;
+    while ((line_len = getline(&buf, &buf_size, file)) != -1) {
+        char *hash;
+        char *filename, *address_str, *id_str, *extra;
+        int n;
+        hwaddr address;
+        int id_entry;
+
+        if (buf[line_len] == '\n')
+            buf[line_len] = '\0';
+
+        hash = strchr(buf, '#');
+        if (hash)
+            *hash = '\0';
+
+        n = sscanf(buf, "%ms %ms %ms %ms", &filename, &address_str, &id_str,
+                   &extra);
+
+        if (n > 3) {
+            error_report("%s: %s:%d ignoring trailing \"%s\"", __func__,
+                         cfg_path, line_number, extra);
+            fclose(file);
+            return NULL;
+        }
+
+        id_entry = CFG_ID_NONE;
+        if (n > 2) {
+            for (id_entry = 0; id_entry < CFG_ID_COUNT; id_entry++)
+                if (!strcmp(id_str, id_names[id_entry]))
+                    goto id_found;
+
+            error_report("%s: %s:%d invalid ID \"%s\"", __func__,
+                         cfg_path, line_number, id_str);
+            fclose(file);
+            return NULL;
+        id_found:
+            ;
+        }
+
+        if (n > 1) {
+            address = strtoull(address_str, &extra, 0);
+            if (address == ULLONG_MAX || *extra != '\0') {
+                error_report("%s: %s:%d error parsing address \"%s\"", __func__,
+                             cfg_path, line_number, address_str);
+                fclose(file);
+                return NULL;
+            }
+
+            if (entries_alloced == num_entries) {
+                entries_alloced += 10;
+                entries = reallocarray(entries, entries_alloced,
+                                       sizeof(struct cfg_entry));
+                if (!entries) {
+                    error_report("%s: Out of memory", __func__);
+                    fclose(file);
+                    return NULL;
+                }
+            }
+
+            entries[num_entries].filename = filename;
+            entries[num_entries].address = address;
+            if (id_entry != CFG_ID_NONE)
+                id_entries[id_entry] = num_entries;
+
+            num_entries++;
+        }
+
+        line_number++;
+    }
+
+    fclose(file);
+
+    *num_entries_p = num_entries;
+    return entries;
+}
+
+static int hobgloblin_load_images(struct cfg_entry* entries,
+                 int num_entries, int id_entries[CFG_ID_COUNT])
+{
+    int i;
+    hwaddr top_dram = hobgoblin_memmap[HOBGOBLIN_DRAM].base +
+        hobgoblin_memmap[HOBGOBLIN_DRAM].size;
+
+    for (i=0; i<num_entries; i++) {
+        hwaddr addr = entries[i].address;
+        if (addr < hobgoblin_memmap[HOBGOBLIN_DRAM].base ||
+            addr >= top_dram) {
+            error_report("%s: Address %#lx outside of memory", __func__, addr);
+            return -1;
+        }
+
+        if (load_image_targphys(entries[i].filename, addr, top_dram - addr) < 0) {
+            error_report("%s: Unable to load \"%s\"", __func__,
+                         entries[i].filename);
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+static void hobgoblin_board_init(MachineState *machine)
+{
+    const struct MemmapEntry *memmap = hobgoblin_memmap;
+    HobgoblinState *s = g_new0(HobgoblinState, 1);
+    MemoryRegion *system_memory = get_system_memory();
+    MemoryRegion *main_mem = g_new(MemoryRegion, 1);
+    MemoryRegion *mask_rom = g_new(MemoryRegion, 1);
+    int i;
+    int id_entries[CFG_ID_COUNT];
+    struct cfg_entry *entries;
+    int num_entries;
+    const int smp_cpus = 1;
+
+    /* Initialize SOC */
+    object_initialize_child(OBJECT(machine), "soc", &s->soc,
+                            TYPE_RISCV_HART_ARRAY);
+    object_property_set_str(OBJECT(&s->soc), "cpu-type",
+                            TYPE_RISCV_CPU_CODASIP_A730, &error_abort);
+    object_property_set_int(OBJECT(&s->soc), "num-harts",
+                            smp_cpus, &error_abort);
+    sysbus_realize(SYS_BUS_DEVICE(&s->soc), &error_fatal);
+
+    /* register system main memory (actual RAM) */
+    memory_region_init_ram(main_mem, NULL, "riscv.hobgoblin.ram",
+                           memmap[HOBGOBLIN_DRAM].size, &error_fatal);
+    memory_region_add_subregion(system_memory, memmap[HOBGOBLIN_DRAM].base,
+                                main_mem);
+
+    /* boot rom */
+    memory_region_init_rom(mask_rom, NULL, "riscv.hobgoblin.mrom",
+                           memmap[HOBGOBLIN_MROM].size, &error_fatal);
+    memory_region_add_subregion(system_memory, memmap[HOBGOBLIN_MROM].base,
+                                mask_rom);
+
+    /* MMIO */
+    s->plic = sifive_plic_create(
+        memmap[HOBGOBLIN_PLIC].base,
+        (char*)HOBGOBLIN_PLIC_HART_CONFIG,
+        smp_cpus, 0,
+        HOBGOBLIN_PLIC_NUM_SOURCES,
+        HOBGOBLIN_PLIC_NUM_PRIORITIES,
+        HOBGOBLIN_PLIC_PRIORITY_BASE,
+        HOBGOBLIN_PLIC_PENDING_BASE,
+        HOBGOBLIN_PLIC_ENABLE_BASE,
+        HOBGOBLIN_PLIC_ENABLE_STRIDE,
+        HOBGOBLIN_PLIC_CONTEXT_BASE,
+        HOBGOBLIN_PLIC_CONTEXT_STRIDE,
+        memmap[HOBGOBLIN_PLIC].size);
+
+    serial_mm_init(system_memory, memmap[HOBGOBLIN_UART0].base + 0x1000, 2,
+                   qdev_get_gpio_in(DEVICE(s->plic), HOBGOBLIN_UART0_IRQ),
+                   115200, serial_hd(0), DEVICE_LITTLE_ENDIAN);
+
+    riscv_aclint_swi_create(memmap[HOBGOBLIN_CLINT].base, 0,
+        smp_cpus, false);
+    riscv_aclint_mtimer_create(memmap[HOBGOBLIN_CLINT].base +
+        RISCV_ACLINT_SWI_SIZE,
+        RISCV_ACLINT_DEFAULT_MTIMER_SIZE, 0, smp_cpus,
+        RISCV_ACLINT_DEFAULT_MTIMECMP, RISCV_ACLINT_DEFAULT_MTIME,
+        CLINT_TIMEBASE_FREQ, true);
+
+     /* Load up the memory */
+    entries = hobgoblin_parse_cfg("config.txt", &num_entries, id_entries);
+    if (!entries ||
+        hobgloblin_load_images(entries, num_entries, id_entries)) {
+        exit(1);
+    }
+
+#define ID_ADDRESS(x) \
+    entries[id_entries[x]].address & 0xffffffff, \
+    entries[id_entries[x]].address >> 32
+
+    /* reset vector */
+    /* We want to end up with:
+     * a0 = heart ID
+     * a1 = device tree blob
+     * a2 = &fw_dynamic_info
+     */
+    uint32_t reset_vec[] = {
+        0x00000297,     /*    0:   auipc   t0,0x0       */
+        0xf1402573,     /*    4:   csrr    a0,mhartid   */
+        0x0182b583,     /*    8:   ld      a1,24(t0)    */
+        0x02828613,     /*    c:   addi    a2,t0,40     */
+        0x0202b283,     /*   10:   ld      t0,32(t0)    */
+        0x00028067,     /*   14:   jr      t0           */
+
+        /* 24: FDT start address */
+        ID_ADDRESS(CFG_ID_FDT),
+        /* 32: OpenSBI start address */
+        ID_ADDRESS(CFG_ID_BOOT),
+
+        /* 40: struct fw_dynamic */
+        0x4942534f, 0,          /* Info magic : "OSBI" */
+        0x2, 0,                 /* Info version : 2 */
+        ID_ADDRESS(CFG_ID_NXT), /* Next booting stage address */
+        0x1, 0,                 /* Next booting stage mode: MODE_S */
+        0x0, 0,                 /* Options for OpenSBI library */
+    };
+
+    /* copy in the reset vector in little_endian byte order */
+    for (i = 0; i < sizeof(reset_vec) >> 2; i++) {
+        reset_vec[i] = cpu_to_le32(reset_vec[i]);
+    }
+    rom_add_blob_fixed_as("mrom.reset", reset_vec, sizeof(reset_vec),
+                          memmap[HOBGOBLIN_MROM].base, &address_space_memory);
+}
+
+static void hobgoblin_machine_init(MachineClass *mc)
+{
+    mc->desc = "RISC-V Hobgoblin Board";
+    mc->init = hobgoblin_board_init;
+    mc->max_cpus = 1;
+}
+
+DEFINE_MACHINE("hobgoblin", hobgoblin_machine_init)
diff --git a/hw/riscv/meson.build b/hw/riscv/meson.build
index 2f7ee81be3..abcf36633d 100644
--- a/hw/riscv/meson.build
+++ b/hw/riscv/meson.build
@@ -8,6 +8,7 @@ riscv_ss.add(when: 'CONFIG_SHAKTI_C', if_true: files('shakti_c.c'))
 riscv_ss.add(when: 'CONFIG_SIFIVE_E', if_true: files('sifive_e.c'))
 riscv_ss.add(when: 'CONFIG_SIFIVE_U', if_true: files('sifive_u.c'))
 riscv_ss.add(when: 'CONFIG_SPIKE', if_true: files('spike.c'))
+riscv_ss.add(when: 'CONFIG_HOBGOBLIN', if_true: files('hobgoblin.c'))
 riscv_ss.add(when: 'CONFIG_MICROCHIP_PFSOC', if_true: files('microchip_pfsoc.c'))
 riscv_ss.add(when: 'CONFIG_ACPI', if_true: files('virt-acpi-build.c'))
 
diff --git a/include/hw/riscv/hobgoblin.h b/include/hw/riscv/hobgoblin.h
new file mode 100644
index 0000000000..d6ff0348d1
--- /dev/null
+++ b/include/hw/riscv/hobgoblin.h
@@ -0,0 +1,43 @@
+/*
+ * QEMU RISC-V Hobgoblin Board
+ *
+ * Copyright (c) 2023 Stuart Menefy, stuart.menefy@codasip.com
+ * Copyright (c) 2023 Codasip Limited
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2 or later, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef HW_RISCV_SPIKE_H
+#define HW_RISCV_SPIKE_H
+
+#include "hw/riscv/riscv_hart.h"
+#include "hw/sysbus.h"
+
+typedef struct {
+    /*< private >*/
+    SysBusDevice parent_obj;
+
+    /*< public >*/
+    RISCVHartArrayState soc;
+    DeviceState *plic;
+} HobgoblinState;
+
+enum {
+    HOBGOBLIN_MROM,
+    HOBGOBLIN_PLIC,
+    HOBGOBLIN_CLINT,
+    HOBGOBLIN_UART0,
+    HOBGOBLIN_DRAM
+};
+
+#endif
-- 
2.39.3

