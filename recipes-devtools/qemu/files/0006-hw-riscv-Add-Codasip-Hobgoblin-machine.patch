From 1f477b9cb0ac16960c7f8056bd7c3a6f205a28d9 Mon Sep 17 00:00:00 2001
From: Axel Heider <axel.heider@codasip.com>
Date: Tue, 19 Mar 2024 13:25:47 +0000
Subject: [PATCH 06/15] hw/riscv: Add Codasip Hobgoblin machine

Initial support for the Hobgoblin FPGA platform, including:
- Boot ROM and SRAM
- DRAM
- PLIC, CLINT
- UART
- GPIO
- SPI + SD-Card connected to it

Two behaviours are supported at boot time. Either:
 - load the FSBL into ROM, which can access an SD card image to
   load any other code, emulating the hardware boot sequence
 - load the OpenSBI/kernel/FDT as qemu does for other platforms

Which behaviour is used depends on a new machine specific option:
"boot-from-rom".

Co-authored-by: Stuart Menefy <stuart.menefy@codasip.com>
Signed-off-by: Axel Heider <axel.heider@codasip.com>
---
 configs/devices/riscv32-softmmu/default.mak |   1 +
 configs/devices/riscv64-softmmu/default.mak |   1 +
 hw/riscv/Kconfig                            |   7 +
 hw/riscv/hobgoblin.c                        | 374 ++++++++++++++++++++
 hw/riscv/meson.build                        |   1 +
 include/hw/riscv/hobgoblin.h                |  66 ++++
 target/riscv/cpu.c                          |   2 +
 7 files changed, 452 insertions(+)
 create mode 100644 hw/riscv/hobgoblin.c
 create mode 100644 include/hw/riscv/hobgoblin.h

diff --git a/configs/devices/riscv32-softmmu/default.mak b/configs/devices/riscv32-softmmu/default.mak
index d847bd5692..aab67871ed 100644
--- a/configs/devices/riscv32-softmmu/default.mak
+++ b/configs/devices/riscv32-softmmu/default.mak
@@ -11,5 +11,6 @@ CONFIG_ARM_COMPATIBLE_SEMIHOSTING=y
 CONFIG_SPIKE=y
 CONFIG_SIFIVE_E=y
 CONFIG_SIFIVE_U=y
+CONFIG_HOBGOBLIN=y
 CONFIG_RISCV_VIRT=y
 CONFIG_OPENTITAN=y
diff --git a/configs/devices/riscv64-softmmu/default.mak b/configs/devices/riscv64-softmmu/default.mak
index bc69301fa4..4f707c07a3 100644
--- a/configs/devices/riscv64-softmmu/default.mak
+++ b/configs/devices/riscv64-softmmu/default.mak
@@ -14,3 +14,4 @@ CONFIG_SIFIVE_U=y
 CONFIG_RISCV_VIRT=y
 CONFIG_MICROCHIP_PFSOC=y
 CONFIG_SHAKTI_C=y
+CONFIG_HOBGOBLIN=y
diff --git a/hw/riscv/Kconfig b/hw/riscv/Kconfig
index b6a5eb4452..e17fe84d8a 100644
--- a/hw/riscv/Kconfig
+++ b/hw/riscv/Kconfig
@@ -85,3 +85,10 @@ config SPIKE
     select HTIF
     select RISCV_ACLINT
     select SIFIVE_PLIC
+
+config HOBGOBLIN
+    bool
+    select RISCV_ACLINT
+    select SIFIVE_PLIC
+    select XILINX_SPI
+    select XILINX_AXI_GPIO
diff --git a/hw/riscv/hobgoblin.c b/hw/riscv/hobgoblin.c
new file mode 100644
index 0000000000..0a39a4b2b2
--- /dev/null
+++ b/hw/riscv/hobgoblin.c
@@ -0,0 +1,374 @@
+/*
+ * QEMU RISC-V Hobgoblin Board
+ *
+ * Copyright (c) 2023 Stuart Menefy, stuart.menefy@codasip.com
+ * Copyright (c) 2023 Codasip Limited
+ *
+ * This provides a RISC-V Board with the following devices:
+ *
+ * 1) CLINT (Timer and IPI)
+ * 2) PLIC (Platform Level Interrupt Controller)
+ * 3) 16550 UART
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2 or later, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/log.h"
+#include "qemu/error-report.h"
+#include "qapi/error.h"
+#include "hw/boards.h"
+#include "hw/loader.h"
+#include "hw/sysbus.h"
+#include "hw/sd/sd.h"
+#include "hw/ssi/ssi.h"
+#include "target/riscv/cpu.h"
+#include "hw/riscv/riscv_hart.h"
+#include "hw/intc/riscv_aclint.h"
+#include "hw/intc/sifive_plic.h"
+#include "hw/riscv/hobgoblin.h"
+#include "hw/riscv/boot.h"
+#include "hw/char/serial.h"
+#include "chardev/char.h"
+#include "sysemu/arch_init.h"
+#include "sysemu/device_tree.h"
+#include "sysemu/qtest.h"
+#include "sysemu/sysemu.h"
+#include "exec/address-spaces.h"
+
+#define TYPE_XILINX_SPI "xlnx.xps-spi"
+#define TYPE_XLNX_AXI_GPIO "xlnx.axi-gpio"
+
+typedef struct {
+    hwaddr base;
+    hwaddr size;
+    const char *name;
+} memmapEntry_t;
+
+static const memmapEntry_t memmap[] = {
+    [HOBGOBLIN_MROM] =     {     0x1000,      0x100,
+        "riscv.hobgoblin.mrom"},
+    [HOBGOBLIN_BOOT_ROM] = { 0x10000000, 0x00010000,
+        "riscv.hobgoblin.boot.rom"},
+    [HOBGOBLIN_BOOT_RAM] = { 0x10400000, 0x00008000,
+        "riscv.hobgoblin.boot.ram"},
+    [HOBGOBLIN_PLIC] =     { 0x40000000,  0x4000000, ""},
+    [HOBGOBLIN_CLINT] =    { 0x60014000,     0xc000, ""},
+    [HOBGOBLIN_UART0] =    { 0x60100000,     0x1020, ""},
+    [HOBGOBLIN_SPI] =      { 0x60210000,     0x1000, ""},
+    [HOBGOBLIN_GPIO0] =    { 0x60300000,    0x10000, ""},
+    [HOBGOBLIN_GPIO1] =    { 0x60310000,    0x10000, ""},
+    [HOBGOBLIN_DRAM] =     { 0x80000000, 0x40000000,
+        "riscv.hobgoblin.ram"},
+};
+
+/* sifive_plic_create() parameters */
+#define HOBGOBLIN_PLIC_NUM_SOURCES      32
+#define HOBGOBLIN_PLIC_NUM_PRIORITIES   7
+#define HOBGOBLIN_PLIC_PRIORITY_BASE    0x0000
+#define HOBGOBLIN_PLIC_PENDING_BASE     0x1000
+#define HOBGOBLIN_PLIC_ENABLE_BASE      0x2000
+#define HOBGOBLIN_PLIC_ENABLE_STRIDE    0x80
+#define HOBGOBLIN_PLIC_CONTEXT_BASE     0x200000
+#define HOBGOBLIN_PLIC_CONTEXT_STRIDE   0x1000
+
+/* CLINT timebase frequency */
+#define CLINT_TIMEBASE_FREQ             100000000 /* 100 MHz */
+
+static int hobgoblin_load_images(MachineState *machine, HobgoblinState_t *s)
+{
+    hwaddr start_addr;
+    uint64_t kernel_entry = 0;
+    uint64_t fdt_load_addr = 0;
+    target_ulong firmware_end_addr;
+
+    if (s->boot_from_rom) {
+        /* Load the FSBL into ROM and set the ZSBL to point to it */
+        start_addr = memmap[HOBGOBLIN_BOOT_ROM].base;
+        firmware_end_addr = riscv_find_and_load_firmware(machine,
+                                                         "fsbl_rom.xexe",
+                                                         start_addr,
+                                                         NULL);
+    } else {
+        target_ulong kernel_start_addr = 0;
+        int fdt_size = 0;
+
+        start_addr = memmap[HOBGOBLIN_DRAM].base;
+
+        /* Read DTB */
+        if (machine->dtb) {
+            machine->fdt = load_device_tree(machine->dtb, &fdt_size);
+            if (!machine->fdt) {
+                error_report("load_device_tree() failed");
+                exit(1);
+            }
+        }
+
+        /* Load SBI into RAM */
+        firmware_end_addr = riscv_find_and_load_firmware(machine,
+                                                         RISCV64_BIOS_BIN,
+                                                         start_addr,
+                                                         NULL);
+
+        /* Load Kernel into RAM */
+        if (machine->kernel_filename) {
+            kernel_start_addr = riscv_calc_kernel_start_addr(&s->soc,
+                                                             firmware_end_addr);
+            kernel_entry = riscv_load_kernel(machine, &s->soc,
+                                             kernel_start_addr, true, NULL);
+        }
+
+        /* Store (potentially modified) FDT into RAM */
+        if (machine->fdt) {
+            fdt_load_addr = riscv_compute_fdt_addr(memmap[HOBGOBLIN_DRAM].base,
+                                                   memmap[HOBGOBLIN_DRAM].size,
+                                                   machine);
+            riscv_load_fdt(fdt_load_addr, machine->fdt);
+        }
+    }
+
+    /*
+     * If no kernel or FTD has been provided, kernel_entry and fdt_load_addr
+     * can be 0 here. For QEMU, this is fine, as they are just parameters
+     * passed to the bootloader, which has to cope with that.
+     */
+    riscv_setup_rom_reset_vec(machine, &s->soc, start_addr,
+            memmap[HOBGOBLIN_MROM].base, memmap[HOBGOBLIN_MROM].size,
+            kernel_entry, fdt_load_addr);
+
+    return 0;
+}
+
+static void hobgoblin_add_soc(HobgoblinState_t *s, MachineState *machine,
+                              const int smp_cpus)
+{
+    object_initialize_child(OBJECT(machine), "soc", &s->soc,
+                            TYPE_RISCV_HART_ARRAY);
+
+    object_property_set_str(OBJECT(&s->soc), "cpu-type",
+                            TYPE_RISCV_CPU_CODASIP_A730, &error_abort);
+
+    object_property_set_int(OBJECT(&s->soc), "num-harts",
+                            smp_cpus, &error_abort);
+
+    sysbus_realize(SYS_BUS_DEVICE(&s->soc), &error_fatal);
+}
+
+static void hobgoblin_add_memory_area(MemoryRegion *system_memory,
+                                      const memmapEntry_t *e)
+{
+    MemoryRegion *reg = g_new(MemoryRegion, 1);
+    memory_region_init_ram(reg, NULL, e->name, e->size, &error_fatal);
+    memory_region_add_subregion(system_memory, e->base, reg);
+}
+
+static void hobgoblin_add_interrupt_controller(HobgoblinState_t *s,
+                                               const int num_harts)
+{
+    const memmapEntry_t *mem_plic = &memmap[HOBGOBLIN_PLIC];
+    const memmapEntry_t *mem_clint = &memmap[HOBGOBLIN_CLINT];
+    const int hartid_base = 0; /* Hart IDs start at 0 */
+
+    /* PLIC */
+    assert(HOBGOBLIN_PLIC_NUM_SOURCES >= HOBGOBLIN_MAX_IRQ);
+    DeviceState *plic = sifive_plic_create(
+        mem_plic->base,
+        "MS", /* instances for both M-Mode and S-Mode */
+        num_harts,
+        hartid_base,
+        HOBGOBLIN_PLIC_NUM_SOURCES,
+        HOBGOBLIN_PLIC_NUM_PRIORITIES,
+        HOBGOBLIN_PLIC_PRIORITY_BASE,
+        HOBGOBLIN_PLIC_PENDING_BASE,
+        HOBGOBLIN_PLIC_ENABLE_BASE,
+        HOBGOBLIN_PLIC_ENABLE_STRIDE,
+        HOBGOBLIN_PLIC_CONTEXT_BASE,
+        HOBGOBLIN_PLIC_CONTEXT_STRIDE,
+        mem_plic->size);
+
+    /* CLINT with SWI in M-Mode */
+    riscv_aclint_swi_create(mem_clint->base, hartid_base, num_harts, false);
+
+    /* CLINT timer */
+    assert(mem_clint->size >= RISCV_ACLINT_SWI_SIZE);
+    riscv_aclint_mtimer_create(
+        mem_clint->base + RISCV_ACLINT_SWI_SIZE,
+        RISCV_ACLINT_DEFAULT_MTIMER_SIZE,
+        hartid_base,
+        num_harts,
+        RISCV_ACLINT_DEFAULT_MTIMECMP,
+        RISCV_ACLINT_DEFAULT_MTIME,
+        CLINT_TIMEBASE_FREQ,
+        true); /* provide_rdtime */
+
+    /* pubslish */
+    s->plic = plic;
+}
+
+static qemu_irq hobgoblin_make_plic_irq(HobgoblinState_t *s, int number)
+{
+    DeviceState *plic = s->plic;
+    assert(plic); /* PLIC instance must exist. */
+    return qdev_get_gpio_in(DEVICE(plic), number);
+}
+
+static void hobgoblin_connect_plic_irq(HobgoblinState_t *s,
+                                       SysBusDevice *busDev, int number)
+{
+    qemu_irq irq = hobgoblin_make_plic_irq(s, number);
+    sysbus_connect_irq(busDev, 0, irq);
+}
+
+static void hobgoblin_add_uart(HobgoblinState_t *s,
+                               MemoryRegion *system_memory)
+{
+    const memmapEntry_t *mem_uart = &memmap[HOBGOBLIN_UART0];
+
+    /* there must be an actual QEMU uart device */
+    Chardev *chardev = serial_hd(0);
+    assert(chardev);
+
+    qemu_irq irq = hobgoblin_make_plic_irq(s, HOBGOBLIN_UART0_IRQ);
+
+    serial_mm_init(system_memory, mem_uart->base + 0x1000, 2, irq, 115200,
+                   chardev, DEVICE_LITTLE_ENDIAN);
+}
+
+static void hobgoblin_add_gpio(HobgoblinState_t *s)
+{
+    for (int i = 0; i < 2; i++) {
+        /* creatio GPIO */
+        DeviceState *gpio = qdev_new(TYPE_XLNX_AXI_GPIO);
+        SysBusDevice *bus_gpio = SYS_BUS_DEVICE(gpio);
+        sysbus_realize_and_unref(bus_gpio, &error_fatal);
+        sysbus_mmio_map(bus_gpio, 0, memmap[HOBGOBLIN_GPIO0 + i].base);
+        /* connect PLIC interrupt */
+        hobgoblin_connect_plic_irq(s, bus_gpio, HOBGOBLIN_GPIO0_IRQ + i);
+        /* publish GPIO device */
+        s->gpio[i] = gpio;
+    }
+}
+
+static void hobgoblin_add_spi(HobgoblinState_t *s)
+{
+    const memmapEntry_t *mem_spi = &memmap[HOBGOBLIN_SPI];
+
+    /* create SPI deivce */
+    DeviceState *spi = qdev_new(TYPE_XILINX_SPI);
+    SysBusDevice *bus_spi = SYS_BUS_DEVICE(spi);
+    sysbus_realize_and_unref(bus_spi, &error_fatal);
+    sysbus_mmio_map(bus_spi, 0, mem_spi->base);
+    /* connect PLIC interrupt */
+    hobgoblin_connect_plic_irq(s, bus_spi, HOBGOBLIN_SPI_IRQ);
+
+    /* create SD Card in SPI mode */
+    DeviceState *sd_card_spi = qdev_new(TYPE_SD_CARD_SPI);
+    DriveInfo *dinfo = drive_get(IF_SD, 0, 0);
+    BlockBackend *blk = dinfo ? blk_by_legacy_dinfo(dinfo) : NULL;
+    qdev_prop_set_drive_err(sd_card_spi, "drive", blk, &error_fatal);
+
+    /* Connect SD card to SPI */
+    SSIBus *bus_ssi = (SSIBus *)qdev_get_child_bus(spi, "spi");
+    DeviceState *sd_dev = ssi_create_peripheral(bus_ssi, "ssi-sd");
+    qdev_realize_and_unref(sd_card_spi,
+                           qdev_get_child_bus(sd_dev, "sd-bus"),
+                           &error_fatal);
+
+    /* publish SPI device */
+    s->spi = spi;
+}
+
+static void hobgoblin_machine_init(MachineState *machine)
+{
+    HobgoblinState_t *s = HOBGOBLIN_MACHINE_STATE(machine);
+
+    MemoryRegion *system_memory = get_system_memory();
+
+    /* Currently there is just one core. */
+    const int smp_cpus = 1;
+
+    hobgoblin_add_soc(s, machine, smp_cpus);
+
+    /* add memory regions */
+    hobgoblin_add_memory_area(system_memory, &memmap[HOBGOBLIN_DRAM]);
+    hobgoblin_add_memory_area(system_memory, &memmap[HOBGOBLIN_MROM]);
+    hobgoblin_add_memory_area(system_memory, &memmap[HOBGOBLIN_BOOT_ROM]);
+    hobgoblin_add_memory_area(system_memory, &memmap[HOBGOBLIN_BOOT_RAM]);
+
+    /* add interrupt controller */
+    hobgoblin_add_interrupt_controller(s, smp_cpus);
+
+    /* add peripherals (requires having an interrupt controller) */
+    hobgoblin_add_uart(s, system_memory);
+    hobgoblin_add_gpio(s);
+    hobgoblin_add_spi(s);
+
+    /* load images into memory to boot the platform */
+    int ret = hobgoblin_load_images(machine, s);
+    if (ret != 0) {
+        error_report("loading images failed (%d)", ret);
+        exit(1);
+    }
+}
+
+static bool hobgoblin_machine_get_boot_from_rom(Object *obj, Error **errp)
+{
+    HobgoblinState_t *s = HOBGOBLIN_MACHINE_STATE(obj);
+
+    return s->boot_from_rom;
+}
+
+static void hobgoblin_machine_set_boot_from_rom(Object *obj, bool value,
+                                                Error **errp)
+{
+    HobgoblinState_t *s = HOBGOBLIN_MACHINE_STATE(obj);
+
+    s->boot_from_rom = value;
+}
+
+static void hobgoblin_machine_instance_init(Object *obj)
+{
+    /* Nothing to be done here. */
+}
+
+static void hobgoblin_machine_class_init(ObjectClass *oc, void *data)
+{
+    MachineClass *mc = MACHINE_CLASS(oc);
+
+    mc->init = hobgoblin_machine_init;
+    /* mc->reset:   void reset(MachineState *state, ShutdownCause reason); */
+    /* mc->wakeup:  void wakeup(MachineState *state); */
+    mc->max_cpus = 1;
+
+    object_class_property_add_bool(oc, "boot-from-rom",
+                                   hobgoblin_machine_get_boot_from_rom,
+                                   hobgoblin_machine_set_boot_from_rom);
+    object_class_property_set_description(oc, "boot-from-rom",
+        "Load BIOS (default fsbl_rom.xexe) into ROM and boot into it");
+}
+
+/* QOM support for HobgoblinState_t */
+static const TypeInfo hobgoblin_typeinfo = {
+    .name          = MACHINE_TYPE_HOBGOBLIN,
+    .parent        = TYPE_MACHINE,
+    .instance_size = sizeof(HobgoblinState_t),
+    .instance_init = hobgoblin_machine_instance_init,
+    .class_init    = hobgoblin_machine_class_init,
+};
+
+static void hobgoblin_register_types(void)
+{
+    type_register_static(&hobgoblin_typeinfo);
+}
+
+type_init(hobgoblin_register_types)
diff --git a/hw/riscv/meson.build b/hw/riscv/meson.build
index 2f7ee81be3..abcf36633d 100644
--- a/hw/riscv/meson.build
+++ b/hw/riscv/meson.build
@@ -8,6 +8,7 @@ riscv_ss.add(when: 'CONFIG_SHAKTI_C', if_true: files('shakti_c.c'))
 riscv_ss.add(when: 'CONFIG_SIFIVE_E', if_true: files('sifive_e.c'))
 riscv_ss.add(when: 'CONFIG_SIFIVE_U', if_true: files('sifive_u.c'))
 riscv_ss.add(when: 'CONFIG_SPIKE', if_true: files('spike.c'))
+riscv_ss.add(when: 'CONFIG_HOBGOBLIN', if_true: files('hobgoblin.c'))
 riscv_ss.add(when: 'CONFIG_MICROCHIP_PFSOC', if_true: files('microchip_pfsoc.c'))
 riscv_ss.add(when: 'CONFIG_ACPI', if_true: files('virt-acpi-build.c'))
 
diff --git a/include/hw/riscv/hobgoblin.h b/include/hw/riscv/hobgoblin.h
new file mode 100644
index 0000000000..b78825c6df
--- /dev/null
+++ b/include/hw/riscv/hobgoblin.h
@@ -0,0 +1,66 @@
+/*
+ * QEMU RISC-V Hobgoblin Board
+ *
+ * Copyright (c) 2023 Stuart Menefy, stuart.menefy@codasip.com
+ * Copyright (c) 2023 Codasip Limited
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2 or later, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef HW_RISCV_HOBGOBLIN_H
+#define HW_RISCV_HOBGOBLIN_H
+
+#include "hw/riscv/riscv_hart.h"
+#include "hw/sysbus.h"
+
+#define MACHINE_TYPE_HOBGOBLIN  MACHINE_TYPE_NAME("hobgoblin")
+
+typedef struct {
+    /*< private >*/
+    MachineState machine; /* QOM: derived from MachineState/TYPE_MACHINE */
+    /*< properties >*/
+    bool boot_from_rom;
+    /*< devices >*/
+    RISCVHartArrayState soc;
+    DeviceState *plic;
+    DeviceState *spi;
+    DeviceState *gpio[2];
+} HobgoblinState_t;
+
+#define HOBGOBLIN_MACHINE_STATE(obj) \
+    OBJECT_CHECK(HobgoblinState_t, (obj), MACHINE_TYPE_HOBGOBLIN);
+
+enum {
+    HOBGOBLIN_MROM,
+    HOBGOBLIN_BOOT_ROM,
+    HOBGOBLIN_BOOT_RAM,
+    HOBGOBLIN_PLIC,
+    HOBGOBLIN_CLINT,
+    HOBGOBLIN_UART0,
+    HOBGOBLIN_SPI,
+    HOBGOBLIN_GPIO0,
+    HOBGOBLIN_GPIO1,
+    HOBGOBLIN_DRAM
+};
+
+enum {
+    /* Interrupt 0 is reserved */
+    HOBGOBLIN_UART0_IRQ    = 1,
+    HOBGOBLIN_SPI_IRQ      = 4,
+    HOBGOBLIN_GPIO0_IRQ    = 7,
+    HOBGOBLIN_GPIO1_IRQ    = 8,
+    /* ----------- */
+    HOBGOBLIN_MAX_IRQ
+};
+
+#endif /* HW_RISCV_HOBGOBLIN_H */
diff --git a/target/riscv/cpu.c b/target/riscv/cpu.c
index 8d7902c21f..4a312d3bde 100644
--- a/target/riscv/cpu.c
+++ b/target/riscv/cpu.c
@@ -551,7 +551,9 @@ static void rv64_codasip_a730_cpu_init(Object *obj)
 
     /* MMU related extensions */
     cpu->cfg.mmu = true;
+#ifndef CONFIG_USER_ONLY
     set_satp_mode_max_supported(cpu, VM_1_10_SV39);
+#endif
     /* Svbare */
     /* Svade */
 
-- 
2.39.3

