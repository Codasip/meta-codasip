From 49667682bd5b29776fd68b722e83af1368e997b9 Mon Sep 17 00:00:00 2001
From: Stuart Menefy <stuart.menefy@codasip.com>
Date: Thu, 21 Mar 2024 16:11:21 +0000
Subject: [PATCH 11/17] net: xilinx_ethlite: Add PHY emulation

Add code to emulate the MDIO_... registers and communicate with a PHY.
Copy the exiting PHY code from the xilinx_axienet.c, although keep
it in a separate file as a first step to generic PHY infrastructure.

Signed-off-by: Stuart Menefy <stuart.menefy@codasip.com>
---
 hw/net/xilinx_ethlite.c     |  45 ++++++++++
 hw/net/xilinx_ethlite_phy.c | 162 ++++++++++++++++++++++++++++++++++++
 2 files changed, 207 insertions(+)
 create mode 100644 hw/net/xilinx_ethlite_phy.c

diff --git a/hw/net/xilinx_ethlite.c b/hw/net/xilinx_ethlite.c
index 989afaf037..e98ef229f6 100644
--- a/hw/net/xilinx_ethlite.c
+++ b/hw/net/xilinx_ethlite.c
@@ -31,8 +31,17 @@
 #include "hw/qdev-properties.h"
 #include "net/net.h"
 
+#include "xilinx_ethlite_phy.c"
+
 #define D(x)
+
 #define R_TX_BUF0     0
+
+#define R_MDIO_ADDR   (0x07e4 / 4)
+#define R_MDIO_WDATA  (0x07e8 / 4)
+#define R_MDIO_RDATA  (0x07ec / 4)
+#define R_MDIO_CTRL   (0x07f0 / 4)
+
 #define R_TX_LEN0     (0x07f4 / 4)
 #define R_TX_GIE0     (0x07f8 / 4)
 #define R_TX_CTRL0    (0x07fc / 4)
@@ -71,6 +80,10 @@ struct xlx_ethlite
     unsigned int rxbuf;
 
     uint32_t regs[R_MAX];
+
+    struct MDIOBus mdio_bus;
+    struct PHY phy;
+    unsigned int c_phyaddr;
 };
 
 static inline void eth_pulse_irq(struct xlx_ethlite *s)
@@ -91,6 +104,10 @@ eth_read(void *opaque, hwaddr addr, unsigned int size)
 
     switch (addr)
     {
+        case R_MDIO_CTRL:
+        case R_MDIO_ADDR:
+        case R_MDIO_WDATA:
+        case R_MDIO_RDATA:
         case R_TX_GIE0:
         case R_TX_LEN0:
         case R_TX_LEN1:
@@ -120,6 +137,27 @@ eth_write(void *opaque, hwaddr addr,
     addr >>= 2;
     switch (addr) 
     {
+        case R_MDIO_CTRL:
+            D(qemu_log("%s addr=" HWADDR_FMT_plx " val=%x\n",
+                       __func__, addr * 4, value));
+            if (value & 1) {
+                uint32_t mdio_addr = s->regs[R_MDIO_ADDR];
+                unsigned int regaddr = (mdio_addr >> 0) & 0x1f;
+                unsigned int phyaddr = (mdio_addr >> 5) & 0x1f;
+                unsigned int op = (mdio_addr >> 10) & 1;
+                uint16_t phy_reg;
+
+                if (!op) {
+                    phy_reg = s->regs[R_MDIO_WDATA];
+                    mdio_write_req(&s->mdio_bus, phyaddr, regaddr, phy_reg);
+                } else {
+                    phy_reg = mdio_read_req(&s->mdio_bus, phyaddr, regaddr);
+                    s->regs[R_MDIO_RDATA] = phy_reg;
+                }
+            }
+            s->regs[addr] = value & (1 << 3);
+            break;
+
         case R_TX_CTRL0:
         case R_TX_CTRL1:
             if (addr == R_TX_CTRL1)
@@ -152,6 +190,9 @@ eth_write(void *opaque, hwaddr addr,
                 qemu_flush_queued_packets(qemu_get_queue(s->nic));
             }
             /* fall through */
+        case R_MDIO_ADDR:
+        case R_MDIO_WDATA:
+        case R_MDIO_RDATA:
         case R_TX_LEN0:
         case R_TX_LEN1:
         case R_TX_GIE0:
@@ -238,6 +279,9 @@ static void xilinx_ethlite_realize(DeviceState *dev, Error **errp)
                           object_get_typename(OBJECT(dev)), dev->id,
                           &dev->mem_reentrancy_guard, s);
     qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);
+
+    tdk_init(&s->phy);
+    mdio_attach(&s->mdio_bus, &s->phy, s->c_phyaddr);
 }
 
 static void xilinx_ethlite_init(Object *obj)
@@ -252,6 +296,7 @@ static void xilinx_ethlite_init(Object *obj)
 }
 
 static Property xilinx_ethlite_properties[] = {
+    DEFINE_PROP_UINT32("phyaddr", struct xlx_ethlite, c_phyaddr, 1),
     DEFINE_PROP_UINT32("tx-ping-pong", struct xlx_ethlite, c_tx_pingpong, 1),
     DEFINE_PROP_UINT32("rx-ping-pong", struct xlx_ethlite, c_rx_pingpong, 1),
     DEFINE_NIC_PROPERTIES(struct xlx_ethlite, conf),
diff --git a/hw/net/xilinx_ethlite_phy.c b/hw/net/xilinx_ethlite_phy.c
new file mode 100644
index 0000000000..d6a9dc0dc3
--- /dev/null
+++ b/hw/net/xilinx_ethlite_phy.c
@@ -0,0 +1,162 @@
+#define DPHY(x)
+
+/* Advertisement control register. */
+#define ADVERTISE_10FULL        0x0040  /* Try for 10mbps full-duplex  */
+#define ADVERTISE_100HALF       0x0080  /* Try for 100mbps half-duplex */
+#define ADVERTISE_100FULL       0x0100  /* Try for 100mbps full-duplex */
+
+#define CONTROL_PAYLOAD_WORDS 5
+#define CONTROL_PAYLOAD_SIZE (CONTROL_PAYLOAD_WORDS * (sizeof(uint32_t)))
+
+struct PHY {
+    uint32_t regs[32];
+
+    int link;
+
+    unsigned int (*read)(struct PHY *phy, unsigned int req);
+    void (*write)(struct PHY *phy, unsigned int req,
+                  unsigned int data);
+};
+
+static unsigned int tdk_read(struct PHY *phy, unsigned int req)
+{
+    int regnum;
+    unsigned r = 0;
+
+    regnum = req & 0x1f;
+
+    switch (regnum) {
+        case 1:
+            if (!phy->link) {
+                break;
+            }
+            /* MR1.  */
+            /* Speeds and modes.  */
+            r |= (1 << 13) | (1 << 14);
+            r |= (1 << 11) | (1 << 12);
+            r |= (1 << 5); /* Autoneg complete.  */
+            r |= (1 << 3); /* Autoneg able.  */
+            r |= (1 << 2); /* link.  */
+            r |= (1 << 1); /* link.  */
+            break;
+        case 5:
+            /* Link partner ability.
+               We are kind; always agree with whatever best mode
+               the guest advertises.  */
+            r = 1 << 14; /* Success.  */
+            /* Copy advertised modes.  */
+            r |= phy->regs[4] & (15 << 5);
+            /* Autoneg support.  */
+            r |= 1;
+            break;
+        case 17:
+            /* Marvell PHY on many xilinx boards.  */
+            r = 0x8000; /* 1000Mb  */
+            break;
+        case 18:
+            {
+                /* Diagnostics reg.  */
+                int duplex = 0;
+                int speed_100 = 0;
+
+                if (!phy->link) {
+                    break;
+                }
+
+                /* Are we advertising 100 half or 100 duplex ? */
+                speed_100 = !!(phy->regs[4] & ADVERTISE_100HALF);
+                speed_100 |= !!(phy->regs[4] & ADVERTISE_100FULL);
+
+                /* Are we advertising 10 duplex or 100 duplex ? */
+                duplex = !!(phy->regs[4] & ADVERTISE_100FULL);
+                duplex |= !!(phy->regs[4] & ADVERTISE_10FULL);
+                r = (speed_100 << 10) | (duplex << 11);
+            }
+            break;
+
+        default:
+            r = phy->regs[regnum];
+            break;
+    }
+    DPHY(qemu_log("\n%s %x = reg[%d]\n", __func__, r, regnum));
+    return r;
+}
+
+static void
+tdk_write(struct PHY *phy, unsigned int req, unsigned int data)
+{
+    int regnum;
+
+    regnum = req & 0x1f;
+    DPHY(qemu_log("%s reg[%d] = %x\n", __func__, regnum, data));
+    switch (regnum) {
+        default:
+            phy->regs[regnum] = data;
+            break;
+    }
+
+    /* Unconditionally clear regs[BMCR][BMCR_RESET] and auto-neg */
+    phy->regs[0] &= ~0x8200;
+}
+
+static void
+tdk_init(struct PHY *phy)
+{
+    phy->regs[0] = 0x3100;
+    /* PHY Id.  */
+    phy->regs[2] = 0x0300;
+    phy->regs[3] = 0xe400;
+    /* Autonegotiation advertisement reg.  */
+    phy->regs[4] = 0x01E1;
+    phy->link = 1;
+
+    phy->read = tdk_read;
+    phy->write = tdk_write;
+}
+
+struct MDIOBus {
+    struct PHY *devs[32];
+};
+
+static void
+mdio_attach(struct MDIOBus *bus, struct PHY *phy, unsigned int addr)
+{
+    bus->devs[addr & 0x1f] = phy;
+}
+
+#ifdef USE_THIS_DEAD_CODE
+static void
+mdio_detach(struct MDIOBus *bus, struct PHY *phy, unsigned int addr)
+{
+    bus->devs[addr & 0x1f] = NULL;
+}
+#endif
+
+static uint16_t mdio_read_req(struct MDIOBus *bus, unsigned int addr,
+                  unsigned int reg)
+{
+    struct PHY *phy;
+    uint16_t data;
+
+    phy = bus->devs[addr];
+    if (phy && phy->read) {
+        data = phy->read(phy, reg);
+    } else {
+        data = 0xffff;
+    }
+    DPHY(qemu_log("%s addr=%d reg=%d data=%x\n", __func__, addr, reg, data));
+    return data;
+}
+
+static void mdio_write_req(struct MDIOBus *bus, unsigned int addr,
+               unsigned int reg, uint16_t data)
+{
+    struct PHY *phy;
+
+    DPHY(qemu_log("%s addr=%d reg=%d data=%x\n", __func__, addr, reg, data));
+    phy = bus->devs[addr];
+    if (phy && phy->write) {
+        phy->write(phy, reg, data);
+    }
+}
+
-- 
2.39.3

